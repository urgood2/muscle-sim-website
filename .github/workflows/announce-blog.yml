name: Announce blog posts to Discord

on:
  push:
    branches: [ main ]
    paths:
      - 'content/**.md'

jobs:
  announce:
    runs-on: ubuntu-latest
    env:
      BASE_URL: ${{ secrets.BASE_URL || 'https://byteden.games' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0   # <-- IMPORTANT: needed for git diff against BEFORE

      - name: Find newly added posts in this push
        id: files
        run: |
          set -euo pipefail
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"
      
          # If BEFORE is the all-zero hash or missing in local history, fetch it (in case of shallow clone on old runs)
          if [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
            git cat-file -e "$BEFORE^{commit}" 2>/dev/null || git fetch --no-tags --depth=1 origin "$BEFORE" || true
          fi
      
          # Choose a safe base for diff:
          # - if BEFORE is valid: use merge-base(BEFORE, AFTER) to survive rebases/force-pushes
          # - else (initial commit): fall back to AFTER^ if it exists, else empty tree
          if git cat-file -e "$BEFORE^{commit}" 2>/dev/null; then
            BASE="$(git merge-base "$BEFORE" "$AFTER")"
          else
            if git rev-parse "$AFTER^" >/dev/null 2>&1; then
              BASE="$(git rev-parse "$AFTER^")"
            else
              BASE="$(git hash-object -t tree /dev/null)"   # empty tree for very first commit
            fi
          fi
      
          # List files Added (A) under content/**.md between BASE..AFTER
          git diff --name-status "$BASE" "$AFTER" \
            | awk '$1=="A" && $2 ~ /^content\/.*\.md$/ {print $2}' > added.txt || true
      
          echo "added=$(paste -sd',' added.txt)" >> "$GITHUB_OUTPUT"
          echo "Added files:"; cat added.txt || true

      - name: Announce each new post
        if: steps.files.outputs.added != ''
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          BASE_URL: ${{ env.BASE_URL }}
        run: |
          set -euo pipefail
          python3 - << 'PY'
          import os, re, sys, json, datetime, pathlib, urllib.error, urllib.request

          webhook = os.environ["DISCORD_WEBHOOK"]
          base = os.environ.get("BASE_URL","").rstrip("/")
          if not webhook or "discord.com/api/webhooks/" not in webhook:
              print("[fatal] DISCORD_WEBHOOK is missing or not a discord.com webhook URL.")
              sys.exit(1)

          with open("added.txt","r") as f:
              files = [line.strip() for line in f if line.strip()]

          def parse_front_matter(text):
              # YAML (---) or TOML (+++)
              if text.startswith('---'):
                  m = re.match(r'^---\s*\n(.*?)\n---\s*\n(.*)$', text, re.S)
                  fmt = 'yaml'
              elif text.startswith('+++'):
                  m = re.match(r'^\+\+\+\s*\n(.*?)\n\+\+\+\s*\n(.*)$', text, re.S)
                  fmt = 'toml'
              else:
                  return {}, text
              if not m:
                  return {}, text
              meta_raw, body = m.group(1), m.group(2)
              try:
                  if fmt == 'yaml':
                      import yaml
                      meta = yaml.safe_load(meta_raw) or {}
                  else:
                      import tomllib
                      meta = tomllib.loads(meta_raw)
              except Exception:
                  meta = {}
              return meta, body

          def markdown_to_discord_text(md: str) -> str:
              # Remove code fences but preserve code inline-ish
              md = re.sub(r'```.*?```', lambda m: '\n\n' + re.sub(r'[\r\n]+', ' ', m.group(0)[3:-3]).strip() + '\n\n', md, flags=re.S)
              # Images: drop
              md = re.sub(r'!\[[^\]]*\]\([^)]+\)', '', md)
              # Links: [text](url) -> text (url)
              md = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', r'\1 (\2)', md)
              # Headings: strip hashes
              md = re.sub(r'^(#{1,6})\s*', '', md, flags=re.M)
              # Excess whitespace
              md = re.sub(r'\r', '', md)
              md = re.sub(r'\n{3,}', '\n\n', md)
              md = re.sub(r'[ \t]+', ' ', md)
              return md.strip()

          def first_image_from_body(body):
              m = re.search(r'!\[[^\]]*\]\(([^)]+)\)', body)
              if m: return m.group(1)
              m = re.search(r'(https?://\S+\.(?:png|jpg|jpeg|gif|webp))', body, re.I)
              return m.group(1) if m else None

          def parse_date(meta):
              for k in ("publishDate","date"):
                  v = meta.get(k)
                  if not v: continue
                  try:
                      return datetime.datetime.fromisoformat(str(v).replace('Z','+00:00'))
                  except Exception:
                      pass
              return None

          def is_draft(meta):
              d = meta.get('draft')
              return bool(d) if d is not None else False

          def should_skip(meta):
              if is_draft(meta): return True, "draft=true"
              dt = parse_date(meta)
              if dt and dt > datetime.datetime.now(datetime.timezone.utc):
                  return True, f"future date {dt.isoformat()}"
              return False, ""

          def chunk(s, n):
              for i in range(0, len(s), n):
                  yield s[i:i+n]

          def post_discord(payload):
              req = urllib.request.Request(webhook, method="POST")
              req.add_header("Content-Type","application/json")
              req.add_header("User-Agent", "BytedenBlogBot/1.0 (+github-actions)")
              data = json.dumps(payload).encode("utf-8")
              try:
                  with urllib.request.urlopen(req, data=data) as resp:
                      if resp.status not in (200,201,202,204):
                          print(f"[warn] Discord returned HTTP {resp.status}")
              except urllib.error.HTTPError as e:
                  body = e.read().decode("utf-8", errors="replace")
                  print(f"[http-error] {e.code} from Discord. Response body:\n{body}")
                  try:
                      j = json.loads(body)
                      print(f"[discord] code={j.get('code')} message={j.get('message')}")
                  except Exception:
                      pass
                  raise

          errors = []
          homepage = base + "/" if base else "/"

          for fp in files:
              try:
                  txt = pathlib.Path(fp).read_text(encoding="utf-8")
                  meta, body = parse_front_matter(txt)
                  skip, reason = should_skip(meta)
                  if skip:
                      print(f"[skip] {fp}: {reason}")
                      continue

                  title = (meta.get('title') or pathlib.Path(fp).stem).strip()
                  img = meta.get('image') or meta.get('featuredImage') or first_image_from_body(body)

                  # Convert full body to Discord-safe text and include it
                  full = markdown_to_discord_text(body)

                  # Build embeds: first carries title/link/image; subsequent carry continuation chunks
                  parts = list(chunk(full, 3000))[:3]  # stay under 4096/description, leave headroom
                  embeds = []
                  for i, part in enumerate(parts):
                      e = {
                          "title": title if i == 0 else f"{title} (cont. {i+1})",
                          "url": homepage,            # <-- link to HOME
                          "description": part,
                      }
                      if i == 0 and img:
                          e["image"] = {"url": img}
                      embeds.append(e)

                  # Also put a simple content line with the homepage link
                  payload = {
                      "username": "Blog Bot",
                      "content": f"**{title}** â†’ {homepage}",
                      "embeds": embeds
                  }

                  post_discord(payload)
                  print(f"[ok] Announced: {title} -> {homepage}")
              except Exception as e:
                  print(f"[err] {fp}: {e}")
                  errors.append((fp, str(e)))

          if errors:
              sys.exit(1)
          PY

      - name: No new posts detected (info)
        if: steps.files.outputs.added == ''
        run: echo "No newly added posts in this push; nothing to announce."
