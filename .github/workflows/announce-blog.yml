name: Announce blog posts to Discord

on:
  push:
    branches: [ main ]
    paths:
      - 'content/**.md'

jobs:
  announce:
    runs-on: ubuntu-latest
    env:
      BASE_URL: ${{ secrets.BASE_URL || 'https://byteden.games' }}
    steps:
      - uses: actions/checkout@v4

      - name: Find newly added posts in this push
        id: files
        run: |
          set -euo pipefail
          # List added files (status A) under content/**.md for this push.
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"
          # Fall back for force-push or initial commit
          if [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
            git diff --name-only --diff-filter=A "$AFTER~1" "$AFTER" | grep -E '^content/.*\.md$' || true
          else
            git diff --name-only --diff-filter=A "$BEFORE" "$AFTER" | grep -E '^content/.*\.md$' || true
          fi > added.txt
          echo "added=$(paste -sd',' added.txt)" >> $GITHUB_OUTPUT
          echo "Added files:"
          cat added.txt || true

      - name: Announce each new post
        if: steps.files.outputs.added != ''
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          BASE_URL: ${{ env.BASE_URL }}
        run: |
          set -euo pipefail
          python3 - << 'PY'
import os, re, sys, json, datetime, pathlib, subprocess

webhook = os.environ["DISCORD_WEBHOOK"]
base = os.environ.get("BASE_URL","").rstrip("/")
added = os.getenv("ADDED_LIST")  # not used
# Read the list produced earlier
with open("added.txt","r") as f:
    files = [line.strip() for line in f if line.strip()]

def parse_front_matter(text):
    # Supports YAML (---) and TOML (+++)
    if text.startswith('---'):
        m = re.match(r'^---\s*\n(.*?)\n---\s*\n(.*)$', text, re.S)
        fmt = 'yaml'
    elif text.startswith('+++'):
        m = re.match(r'^\+\+\+\s*\n(.*?)\n\+\+\+\s*\n(.*)$', text, re.S)
        fmt = 'toml'
    else:
        return {}, text
    if not m:
        return {}, text
    meta_raw, body = m.group(1), m.group(2)
    data = {}
    try:
        if fmt == 'yaml':
            import yaml  # PyYAML is available on ubuntu-latest
            data = yaml.safe_load(meta_raw) or {}
        else:
            import tomllib  # Python 3.11
            data = tomllib.loads(meta_raw)
    except Exception:
        data = {}
    return data, body

def first_image_from_body(body):
    # Markdown image ![alt](url) or plain http image link
    m = re.search(r'!\[[^\]]*\]\(([^)]+)\)', body)
    if m: return m.group(1)
    m = re.search(r'(https?://\S+\.(?:png|jpg|jpeg|gif|webp))', body, re.I)
    return m.group(1) if m else None

def summarize(body, limit=300):
    # strip code fences and markdown links
    b = re.sub(r'```.*?```', '', body, flags=re.S)
    b = re.sub(r'\[([^\]]+)\]\([^)]+\)', r'\1', b)
    b = re.sub(r'!\[[^\]]*\]\([^)]+\)', '', b)
    b = re.sub(r'\s+', ' ', b).strip()
    return (b[:limit] + 'â€¦') if len(b) > limit else b

def build_url(fp, meta):
    # Priority: meta.url > (section + slug) > path derived
    if 'url' in meta and meta['url']:
        u = str(meta['url'])
        if u.startswith('http'): return u
        return f"{base}/{u.lstrip('/')}"
    # derive from path
    p = pathlib.Path(fp)
    # Remove leading content/
    parts = p.parts
    if parts[0] == 'content':
        parts = parts[1:]
    # remove extension
    if parts[-1].endswith('.md'):
        parts = parts[:-1] + (parts[-1][:-3],)
    # If front matter provides slug, replace last segment
    slug = (meta.get('slug') or meta.get('permalink') or '').strip() if meta else ''
    if slug:
        parts = (*parts[:-1], slug)
    # Join; Hugo typically adds trailing slash
    return f"{base}/{'/'.join(parts).strip('/')}/"

def parse_date(meta):
    # Accept date/publishDate as ISO or yyyy-mm-dd
    for k in ("publishDate","date"):
        v = meta.get(k)
        if not v: continue
        try:
            return datetime.datetime.fromisoformat(str(v).replace('Z','+00:00'))
        except Exception:
            pass
    return None

def is_draft(meta):
    d = meta.get('draft')
    return bool(d) if d is not None else False

def should_skip(meta):
    # Skip drafts and future-dated posts
    if is_draft(meta): return True, "draft=true"
    dt = parse_date(meta)
    if dt and dt > datetime.datetime.now(datetime.timezone.utc):
        return True, f"future date {dt.isoformat()}"
    return False, ""

import urllib.request
def post_discord(payload):
    req = urllib.request.Request(webhook, method="POST")
    req.add_header("Content-Type","application/json")
    data = json.dumps(payload).encode("utf-8")
    with urllib.request.urlopen(req, data=data) as resp:
        resp.read()

errors = []
for fp in files:
    try:
        with open(fp, "r", encoding="utf-8") as f:
            txt = f.read()
        meta, body = parse_front_matter(txt)
        skip, reason = should_skip(meta)
        if skip:
            print(f"[skip] {fp}: {reason}")
            continue

        title = (meta.get('title') or '').strip()
        if not title:
            # fallback to filename
            title = pathlib.Path(fp).stem

        url = build_url(fp, meta)
        img = meta.get('image') or meta.get('featuredImage') or first_image_from_body(body)
        desc = (meta.get('summary') or meta.get('description') or summarize(body))

        tags = meta.get('tags') or meta.get('categories') or []
        if isinstance(tags, str): tags = [tags]

        embed = {
            "title": title,
            "url": url,
            "description": desc[:1000],  # Discord embed description limit ~4096; keep it tight
        }
        if img:
            embed["image"] = {"url": img}

        if tags:
            # Add a small field for tags
            embed.setdefault("fields", []).append({
                "name": "Tags",
                "value": ", ".join(str(t) for t in tags)[:1000],
                "inline": True
            })

        payload = {
            "username": "Blog Bot",
            "embeds": [embed]
        }

        post_discord(payload)
        print(f"[ok] Announced: {title} -> {url}")
    except Exception as e:
        print(f"[err] {fp}: {e}")
        errors.append((fp, str(e)))

if errors:
    sys.exit(1)
PY

      - name: No new posts detected (info)
        if: steps.files.outputs.added == ''
        run: echo "No newly added posts in this push; nothing to announce."
