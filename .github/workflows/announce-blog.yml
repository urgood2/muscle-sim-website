name: Announce blog posts to Discord

on:
  push:
    branches: [ main ]
    paths:
      - 'content/**.md'

jobs:
  announce:
    runs-on: ubuntu-latest
    env:
      BASE_URL: ${{ secrets.BASE_URL || 'https://byteden.games' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0   # <-- IMPORTANT: needed for git diff against BEFORE

      - name: Find newly added posts in this push
        id: files
        run: |
          set -euo pipefail
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"
      
          # If BEFORE is the all-zero hash or missing in local history, fetch it (in case of shallow clone on old runs)
          if [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
            git cat-file -e "$BEFORE^{commit}" 2>/dev/null || git fetch --no-tags --depth=1 origin "$BEFORE" || true
          fi
      
          # Choose a safe base for diff:
          # - if BEFORE is valid: use merge-base(BEFORE, AFTER) to survive rebases/force-pushes
          # - else (initial commit): fall back to AFTER^ if it exists, else empty tree
          if git cat-file -e "$BEFORE^{commit}" 2>/dev/null; then
            BASE="$(git merge-base "$BEFORE" "$AFTER")"
          else
            if git rev-parse "$AFTER^" >/dev/null 2>&1; then
              BASE="$(git rev-parse "$AFTER^")"
            else
              BASE="$(git hash-object -t tree /dev/null)"   # empty tree for very first commit
            fi
          fi
      
          # List files Added (A) under content/**.md between BASE..AFTER
          git diff --name-status "$BASE" "$AFTER" \
            | awk '$1=="A" && $2 ~ /^content\/.*\.md$/ {print $2}' > added.txt || true
      
          echo "added=$(paste -sd',' added.txt)" >> "$GITHUB_OUTPUT"
          echo "Added files:"; cat added.txt || true

      - name: Announce each new post
        if: steps.files.outputs.added != ''
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          BASE_URL: ${{ env.BASE_URL }}
        run: |
          set -euo pipefail
          python3 - << 'PY'
          import os, re, sys, json, datetime, pathlib, subprocess, urllib.error
          
          webhook = os.environ["DISCORD_WEBHOOK"]
          base = os.environ.get("BASE_URL","").rstrip("/")
          # Minimal sanity check to catch empty/garbled secrets early
          if not webhook or "discord.com/api/webhooks/" not in webhook:
            print("[fatal] DISCORD_WEBHOOK is missing or not a discord.com webhook URL.")
            sys.exit(1)
          added = os.getenv("ADDED_LIST")  # not used
          # Read the list produced earlier
          with open("added.txt","r") as f:
              files = [line.strip() for line in f if line.strip()]
          
          def parse_front_matter(text):
              # Supports YAML (---) and TOML (+++)
              if text.startswith('---'):
                  m = re.match(r'^---\s*\n(.*?)\n---\s*\n(.*)$', text, re.S)
                  fmt = 'yaml'
              elif text.startswith('+++'):
                  m = re.match(r'^\+\+\+\s*\n(.*?)\n\+\+\+\s*\n(.*)$', text, re.S)
                  fmt = 'toml'
              else:
                  return {}, text
              if not m:
                  return {}, text
              meta_raw, body = m.group(1), m.group(2)
              data = {}
              try:
                  if fmt == 'yaml':
                      import yaml  # PyYAML is available on ubuntu-latest
                      data = yaml.safe_load(meta_raw) or {}
                  else:
                      import tomllib  # Python 3.11
                      data = tomllib.loads(meta_raw)
              except Exception:
                  data = {}
              return data, body
          
          def first_image_from_body(body):
              # Markdown image ![alt](url) or plain http image link
              m = re.search(r'!\[[^\]]*\]\(([^)]+)\)', body)
              if m: return m.group(1)
              m = re.search(r'(https?://\S+\.(?:png|jpg|jpeg|gif|webp))', body, re.I)
              return m.group(1) if m else None
          
          def summarize(body, limit=300):
              # strip code fences and markdown links
              b = re.sub(r'```.*?```', '', body, flags=re.S)
              b = re.sub(r'\[([^\]]+)\]\([^)]+\)', r'\1', b)
              b = re.sub(r'!\[[^\]]*\]\([^)]+\)', '', b)
              b = re.sub(r'\s+', ' ', b).strip()
              return (b[:limit] + 'â€¦') if len(b) > limit else b
          
          def build_url(fp, meta):
              # Priority: meta.url > (section + slug) > path derived
              if 'url' in meta and meta['url']:
                  u = str(meta['url'])
                  if u.startswith('http'): return u
                  return f"{base}/{u.lstrip('/')}"
              # derive from path
              p = pathlib.Path(fp)
              # Remove leading content/
              parts = p.parts
              if parts[0] == 'content':
                  parts = parts[1:]
              # remove extension
              if parts[-1].endswith('.md'):
                  parts = parts[:-1] + (parts[-1][:-3],)
              # If front matter provides slug, replace last segment
              slug = (meta.get('slug') or meta.get('permalink') or '').strip() if meta else ''
              if slug:
                  parts = (*parts[:-1], slug)
              # Join; Hugo typically adds trailing slash
              return f"{base}/{'/'.join(parts).strip('/')}/"
          
          def parse_date(meta):
              # Accept date/publishDate as ISO or yyyy-mm-dd
              for k in ("publishDate","date"):
                  v = meta.get(k)
                  if not v: continue
                  try:
                      return datetime.datetime.fromisoformat(str(v).replace('Z','+00:00'))
                  except Exception:
                      pass
              return None
          
          def is_draft(meta):
              d = meta.get('draft')
              return bool(d) if d is not None else False
          
          def should_skip(meta):
              # Skip drafts and future-dated posts
              if is_draft(meta): return True, "draft=true"
              dt = parse_date(meta)
              if dt and dt > datetime.datetime.now(datetime.timezone.utc):
                  return True, f"future date {dt.isoformat()}"
              return False, ""
          
          import urllib.request, time
          def post_discord(payload):
              req = urllib.request.Request(webhook, method="POST")
              req.add_header("Content-Type","application/json")
              # Set a UA; some Discord edges are stricter for non-browser clients
              req.add_header("User-Agent", "BytedenBlogBot/1.0 (+github-actions)")
              data = json.dumps(payload).encode("utf-8")
              try:
                  with urllib.request.urlopen(req, data=data) as resp:
                      # Discord webhooks return 204 No Content on success
                      status = resp.status
                      if status not in (200, 201, 202, 204):
                          print(f"[warn] Discord returned HTTP {status}")
              except urllib.error.HTTPError as e:
                  body = e.read().decode("utf-8", errors="replace")
                  print(f"[http-error] {e.code} from Discord. Response body:\n{body}")
                  # Surface structured API error (e.g., {"message":"Missing Access","code":50001})
                  try:
                      j = json.loads(body)
                      print(f"[discord] code={j.get('code')} message={j.get('message')}")
                  except Exception:
                      pass
                  raise
          
          errors = []
          for fp in files:
              try:
                  with open(fp, "r", encoding="utf-8") as f:
                      txt = f.read()
                  meta, body = parse_front_matter(txt)
                  skip, reason = should_skip(meta)
                  if skip:
                      print(f"[skip] {fp}: {reason}")
                      continue
          
                  title = (meta.get('title') or '').strip()
                  if not title:
                      # fallback to filename
                      title = pathlib.Path(fp).stem
          
                  url = build_url(fp, meta)
                  img = meta.get('image') or meta.get('featuredImage') or first_image_from_body(body)
                  desc = (meta.get('summary') or meta.get('description') or summarize(body))
          
                  tags = meta.get('tags') or meta.get('categories') or []
                  if isinstance(tags, str): tags = [tags]
          
                  embed = {
                      "title": title,
                      "url": url,
                      "description": desc[:1000],  # Discord embed description limit ~4096; keep it tight
                  }
                  if img:
                      embed["image"] = {"url": img}
          
                  if tags:
                      # Add a small field for tags
                      embed.setdefault("fields", []).append({
                          "name": "Tags",
                          "value": ", ".join(str(t) for t in tags)[:1000],
                          "inline": True
                      })
          
                  payload = {
                      "username": "Blog Bot",
                      "embeds": [embed]
                  }
          
                  post_discord(payload)
                  print(f"[ok] Announced: {title} -> {url}")
              except Exception as e:
                  print(f"[err] {fp}: {e}")
                  errors.append((fp, str(e)))
          
          if errors:
              sys.exit(1)
          PY
          
                - name: No new posts detected (info)
                  if: steps.files.outputs.added == ''
                  run: echo "No newly added posts in this push; nothing to announce."
